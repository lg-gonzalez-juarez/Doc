I"¢<h2 id="typecasting">Typecasting</h2>

<p>Up to this point, we‚Äôve worked with a lot of different types, but before we can start taking user input and do interesting things with it we‚Äôll need to convert from one type to another. This process is called ‚Äútypecasting‚Äù.</p>

<h3 id="documentation-for-this-video">Documentation For This Video</h3>

<p><a href="https://docs.python.org/3/library/functions.html#int">Typecasting: int</a>
<a href="https://docs.python.org/3/library/functions.html#float">Typecasting: float</a>
<a href="https://docs.python.org/3/library/functions.html#str">Typecasting: str</a>
<a href="https://docs.python.org/3/library/functions.html#bool">Typecasting: bool</a>
<a href="https://docs.python.org/3/library/stdtypes.html#truth-value-testing">Trust Value Testing</a></p>

<h3 id="converting-from-a-number-type-to-a-number-type">Converting from a Number Type to a Number Type</h3>

<p>We‚Äôve already seen some typecasting happen behind the scenes when we performed some of the mathematical operations. For instance, performing ‚Äútrue division‚Äù (using the / operator) will always return a float even if we provide two integer operands. How do we go about converting from an integer to a float ourselves though?</p>

<p>The answer is by using the float initializer.</p>

<pre><code class="language-cmd">&gt;&gt;&gt; float(1)
1.0
</code></pre>

<p>We can do the same thing going from a float to an integer using the int initializer:</p>

<pre><code class="language-cmd">&gt;&gt;&gt; int(1.3)
1
&gt;&gt;&gt; int(2.6)
2
</code></pre>

<p>Notice that the result from converting 2.6 to an integer doesn‚Äôt round, it truncates. It‚Äôs as though the decimal point value doesn‚Äôt exist.</p>

<p>Converting between number types is pretty straight forward because they‚Äôre both numbers, but what happens if we try to convert to and from a string?</p>

<h3 id="converting-to-and-from-a-string">Converting to and from a String</h3>

<p>Converting to a string is done by using the str initializer and the results are what you would expect:</p>

<pre><code class="language-cmd">&gt;&gt;&gt; str(1)
'1'
&gt;&gt;&gt; str(2.6)
'2.6'
&gt;&gt;&gt; str(False)
'False'
</code></pre>

<p>As we see, even booleans can be typecast to strings. More interesting than converting to strings is trying to convert strings into other usable types, like integers and floats:</p>

<pre><code class="language-cmd">&gt;&gt;&gt; int('1')
1
&gt;&gt;&gt; float('1')
1.0
&gt;&gt;&gt; float('1.2')
1.2
&gt;&gt;&gt; int('1.2')
### Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
ValueError: invalid literal for int() with base 10: '1.2'
</code></pre>

<p>If the string contains something that would be a valid int or float if we typed it into the interpreter, then we‚Äôre able to typecast it. But as soon as the type doesn‚Äôt match, or we try to convert something that‚Äôs not a number to a float or int, then we‚Äôll run into issues.</p>

<h3 id="converting-to-a-boolean">Converting to a Boolean</h3>

<p>One of the more important, and subtle type, conversions that we use in programming is casting to a boolean. We can cast anything to a boolean in Python by using the bool function.</p>

<pre><code class="language-cmd">&gt;&gt;&gt; bool(1)
True
&gt;&gt;&gt; bool(2.4)
True
&gt;&gt;&gt; bool('Tada')
True
&gt;&gt;&gt; bool('Tada'.lower)
True
&gt;&gt;&gt; bool(0)
False
&gt;&gt;&gt; bool(0.0)
False
&gt;&gt;&gt; bool("")
False
</code></pre>

<p>There are a select few items that convert into False. These are detailed in the Python truth value testing documentation, but can be summed up as False, None, any 0 value, and any empty sequence (an empty string for instance).</p>

<h3 id="boolean-operators-with-non-boolean-objects">Boolean Operators with Non-Boolean Objects</h3>

<p>Now that we know that every object has a boolean representation, we‚Äôre ready to revisit the boolean operators of and, or, and not. These operators will operate on any objects by using their boolean representations automatically.</p>

<p>These operations get a little more complicated as we use non-boolean operands:</p>

<pre><code class="language-cmd">&gt;&gt;&gt; 1 and 0
0
&gt;&gt;&gt; 'This' and 'That'
'That'
&gt;&gt;&gt; 'This' and 0 and 'That'
0
&gt;&gt;&gt; 0.0 and 1
0.0
</code></pre>

<p>Remember that and requires both operands to be true in order to return true, and this means that it will automatically return the first falsy value that it finds or the rightmost operand if they‚Äôre both true.</p>

<p>The or operator works in the opposite way. It will return the first object that would evaluate to true, or the rightmost falsy value.</p>

<pre><code class="language-cmd">&gt;&gt;&gt; 1 or 0
1
&gt;&gt;&gt; 0 or 1
1
&gt;&gt;&gt; 0 or ""
""
&gt;&gt;&gt; 0 or 1 or 'This'
1
</code></pre>

<p>Lastly, the not operator will simply return the opposite boolean value for whatever we pass to it:</p>

<pre><code class="language-cmd">&gt;&gt;&gt; not ""
True
&gt;&gt;&gt; not 1
False
</code></pre>

:ET