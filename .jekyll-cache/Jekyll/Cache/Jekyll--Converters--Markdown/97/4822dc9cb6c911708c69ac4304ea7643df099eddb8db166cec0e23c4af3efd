I"©(<h2 id="function-basics">Function Basics</h2>

<h3 id="defining-and-using-functions">Defining and Using Functions</h3>

<p>Being able to write code that we can call multiple times without repeating ourselves is one of the most powerful things that we can do when programming. Let‚Äôs learn how to define functions in Python.</p>

<h3 id="documentation-for-this-video">Documentation For This Video</h3>

<p><a href="https://docs.python.org/3/tutorial/controlflow.html#defining-functions">Defining Functions</a></p>

<h3 id="function-basics-1">Function Basics</h3>

<p>We can create functions in Python using the following:</p>

<ul>
  <li>The def keyword</li>
  <li>The function name - lowercase starting with a letter or underscore (_)</li>
  <li>Left parenthesis (()</li>
  <li>0 or more parameter names</li>
  <li>Right parenthesis ())</li>
  <li>A colon :</li>
  <li>An indented function body</li>
</ul>

<p>Here‚Äôs an example without any parameters:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; def hello_world():
...     print("Hello, World!")
...
&gt;&gt;&gt; hello_world()
Hello, World!
&gt;&gt;&gt;
</code></pre></div></div>

<p>If we want to define a parameter, we will put the variable name we want it to have within the parentheses:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; def print_name(name):
...     print(f"Name is {name}")
...
&gt;&gt;&gt; print_name("Keith")
Name is Keith
</code></pre></div></div>

<p>Let‚Äôs try to assign the value from print_name to a variable called output:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; output = print_name("Keith")
Name is Keith
&gt;&gt;&gt; output
&gt;&gt;&gt;
</code></pre></div></div>

<p>Neither of these examples has a return value, but we will usually want to have a return value unless the function is our ‚Äúmain‚Äù function or carries out a ‚Äúside-effect‚Äù like printing. If we don‚Äôt explicitly declare a return value, then the result will be None (as you saw when our body used print).</p>

<p>We can declare what we‚Äôre returning from a function using the return keyword:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; def add_two(num):
...     return num + 2
...
&gt;&gt;&gt; result = add_two(2)
&gt;&gt;&gt; result
4
</code></pre></div></div>
<h3 id="working-with-multiple-parameters">Working with Multiple Parameters</h3>

<p>When we have a function that takes multiple parameters, we need to separate them using commas and give them unique names:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; def add(num1, num2):
...     return num1 + num2
...
&gt;&gt;&gt; result = add(1, 5)
&gt;&gt;&gt; result
6
</code></pre></div></div>

<h2 id="parameters-vs-arguments">Parameters vs. Arguments</h2>

<p>When talking about functions, the words ‚Äúparameter‚Äù and ‚Äúargument‚Äù are often used interchangeably. But they represent two different things. In this lesson, we‚Äôll look at the differences between parameters and arguments, and the different ways we can use arguments when calling functions.</p>

<h3 id="documentation-for-this-video-1">Documentation For This Video</h3>

<p><a href="https://docs.python.org/3/tutorial/controlflow.html#defining-functions">Defining Functions</a></p>

<h3 id="parameters-vs-aruguments">Parameters VS Aruguments</h3>

<p>The difference between a parameter and an argument is all about timing. When we‚Äôre working with the definition of a function, then the variables defined in the function declaration are the ‚Äúparameters.‚Äù When we‚Äôre calling the function, the data that we provide for each parameter is the ‚Äúargument.‚Äù Accidentally using these words interchangeably in practice isn‚Äôt an issue, because other programmers will know exactly what you‚Äôre talking about. But it is good to know that there is a distinction.</p>

<p>With the semantic differences covered, we‚Äôre ready to move onto the more interesting topic of the various types of arguments that we can use: position and keyword arguments.</p>

<h2 id="using-keyword-arguments">Using Keyword Arguments</h2>

<p>Every function call we‚Äôve made up to this point has used what are known as positional arguments. But if we know the name of the parameters, and not necessarily the positions, we can all them all using keyword arguments like so:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; def contact_card(name, age, car_model):
...     return f"{name} is {age} and drives a {car_model}"
...
&gt;&gt;&gt; contact_card("Keith", 29, "Honda Civic")
'Keith is 29 and drives a Honda Civic'
&gt;&gt;&gt; contact_card(age=29, car_model="Civic", name="Keith")
'Keith is 29 and drives a Civic'
&gt;&gt;&gt; contact_card("Keith", car_model="Civic", age="29")
'Keith is 29 and drives a Civic'
&gt;&gt;&gt; contact_card(age="29", "Keith", car_model="Civic")
  File "&lt;stdin&gt;", line 1
SyntaxError: positional argument follows keyword argument
</code></pre></div></div>

<p>When we‚Äôre using position and keyword arguments, every argument after the first keyword argument must also be a keyword argument. It‚Äôs sometimes useful to mix them, but oftentimes we‚Äôll use either all positional or all keyword.</p>

<h3 id="defining-parameters-with-default-arguments">Defining Parameters with Default Arguments</h3>

<p>Along with being able to use keyword arguments when we‚Äôre calling a function, we‚Äôre able to define default values for parameters to make them optional when the information is commonly known and the same. To do this, we use the assignment operator (=) when we‚Äôre defining the parameter:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; def can_drive(age, driving_age=16):
...     return age &gt;= driving_age
...
&gt;&gt;&gt; can_drive(16)
True
&gt;&gt;&gt; can_drive(16, driving_age=18)
False
</code></pre></div></div>

<p>Parameters with default arguments need to go at the end of the parameters list when defining the function so that positional arguments can still be used to call the function.</p>

<h2 id="recursion">Recursion</h2>

<p>It might not seem immediately obvious, but we‚Äôre capable of calling a function from within itself. This practice is called recursion. In this lesson, we‚Äôll learn how we can use recursion and some of the pitfalls that surround it.</p>

<h3 id="documentation-for-this-video-2">Documentation For This Video</h3>

<p><a href="https://docs.python.org/3/tutorial/controlflow.html#defining-functions">Defining Functions</a>
<a href="https://docs.python.org/3.7/library/sys.html#sys.getrecursionlimit">The sys.getrecursionlimit Function</a></p>

<h3 id="solving-problems-with-recursion">Solving Problems with Recursion</h3>

<p>Recursion is the practice of calling a function from within itself. This might not seem like something that you‚Äôd ever do at first, but occasionally the best way to solve a problem is to break it up into smaller versions of the same problem. The canonical example of this is calculating the Fibonacci Sequence (1, 1, 2, 3, 5, 8, etc.). In the Fibonacci sequence, the next number is always the sum of the previous two numbers in the sequence. If we write this out as a mathematical function, then calculating the nth item in the Fibonacci sequence would look something like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>f(n) = f(n-2) + f(n-1)
</code></pre></div></div>

<p>So, for the 5th item in the sequence (which coincidently is also 5), we would expand it like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>f(5) = f(3) + f(4)
f(5) = f(1) + f(2) + f(2) + f(3)
f(5) = 1 + f(0) + f(1) + f(0) + f(1) + f(1) + f(2)
f(5) = 1 + 0 + 1 + 0 + 1 + 1 + f(0) + f(1)
f(5) = 1 + 0 + 1 + 0 + 1 + 1 + 0 + 1
f(5) = 5
</code></pre></div></div>

<p>For recursion to work, there has to be what is called a ‚Äúbase case,‚Äù where something is returned other than the result of the function calling itself. In the case of our Fibonacci sequence function, the base case(s) are that f(0) will return 0, and f(1) will return 1. Now that we can visualize exactly what is going on, let‚Äôs write this function in Python:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>~/fib.py

def fib(n):
    if n == 0:
        return 0
    elif n == 1:
        return 1

    return fib(n - 2) + fib(n - 1)

item_to_calculate = int(input("What Fibonnaci item would you like to calculate? "))

print(fib(item_to_calculate))
</code></pre></div></div>

<p>In writing our function, we needed to remember a few things:</p>

<ol>
  <li>We need to handle the base cases first.</li>
  <li>We return what we would normally consider the implementation of the function. This return allows us to essentially gather all of the results at the end.</li>
</ol>

<p>Let‚Äôs run our script:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ python3.7 fib.py
What Fibonacci item would you like to calculate? 15
610
</code></pre></div></div>

<p>That was pretty fast, but as we increase the number from 15 to 30, we should see it take significantly longer to return. This is because the number of recursive function calls that happen as we try to calculate higher and higher terms gets excessively large. Trying to calculate the 50th term using our implementation might not ever return.</p>

<h3 id="the-limits-of-recursion">The Limits of Recursion</h3>

<p>We‚Äôve run into the main issue with recursion, every time we recurse it, we‚Äôre adding more and more function calls to the stack of calls that need to be completed. Some languages are optimized to handle this by implementing something called ‚Äútail-call optimization,‚Äù but Python is not one of those languages. Recursion is a useful tool at times, but it does require being delicate and layering in some manual optimization (which we won‚Äôt be covering here).</p>

:ET