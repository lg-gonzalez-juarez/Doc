I"ö<h2 id="151-scoping">15.1. Scoping</h2>

<h2 id="python-scopes">Python Scopes</h2>

<p>We‚Äôve lightly touched on this already, but when working with any programming language, the variables and objects that we‚Äôre working with are only accessible within certain scopes. In this lesson, we‚Äôll take a closer look at how scopes work and when our variables might not be what we expect them to be.</p>

<h3 id="what-is-a-scope">What is a Scope?</h3>

<p>When we say that we‚Äôre working in a different ‚Äúscope‚Äù in Python, we mean that we‚Äôre within the boundaries of a function or a class. This is important because while within the body of a function or class, the variables that we create are not automatically accessible outside of that context. Let‚Äôs create a new file called scopes.py so that we can experiment with how scopes work. To start, let‚Äôs see how variables work when dealing with conditionals and loops.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scopes.py

if 1 &lt; 2:
    x = 5

while x &lt; 6:
    print(x)
    x += 1

print(x)
</code></pre></div></div>

<p>Here we‚Äôre creating a variable (x=5) within the body of a conditional (if 1 &lt; 2:1). Afterward, we attempt to access that variable within the context of a loop (while x &lt; 6:) and at the highest level of our script. Will this work? Let‚Äôs find out by running this through the interpreter:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ python3.7 scopes.py
5
6
$
</code></pre></div></div>

<p>We didn‚Äôt run into an error because conditionals and loops do not create scopes. Now, let‚Äôs change our conditional to be a function instead.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scopes.py

def set_x():
    x = 5

set_x()

while x &lt; 6:
    print(x)
    x += 1

print(x)
</code></pre></div></div>

<p>Now if we run this we‚Äôll see the following:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ python3.7 scopes.py
Traceback (most recent call last):
  File "scopes.py", line 7, in &amp;lt;module&gt;
    while x &lt; 6:
NameError: name 'x' is not defined
$
</code></pre></div></div>

<p>We see this error because x is defined within the set_x function and only exists during the execution of the function.</p>

<h2 id="152-name-hiding-shadowing">15.2. Name Hiding (Shadowing)</h2>

<p>Now that we‚Äôve looked at how scopes work initially, we‚Äôre ready to look at what happens when we have a function parameter that is the same as a variable that exists at a higher level. This is sometimes called shadowing or name hiding.</p>

<h3 id="name-hiding-in-action">Name Hiding in Action</h3>

<p>We know that functions create scopes. But, what happens when a parameter name is the same as a variable that has already been defined? Let‚Äôs continue using scopes.py to see what happens when we set y before we define the set_x function, and then change our function to have a y parameter:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scopes.py

y = 5

def set_x(y):
    print("Inner y:", y)
    x = y
    y = x

set_x(10)
print("Outer y:", y)
</code></pre></div></div>

<p>Now if we run this, we‚Äôll see the following:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ python3.7 scopes.py
Inner y: 10
Outer y: 5
</code></pre></div></div>

<p>Since our function defines the y parameter, it‚Äôs as though the outer y variable doesn‚Äôt exist within the set_x function. Name hiding makes it possible for us to be confident that our parameters won‚Äôt be affected by values at a higher scope. That doesn‚Äôt mean that name hiding is something that we should always use though because it can make our code a little harder for people to understand.</p>

<h2 id="153-the-global-keyword">15.3. The <code class="language-plaintext highlighter-rouge">global</code> Keyword</h2>

<p>Occasionally, we want to be able to modify a global variable from within a more specific context. In this situation, Python provides us with the global keyword. In this lesson, we‚Äôll learn how to use the global keyword.</p>

<h3 id="documentation">Documentation</h3>
<p><a href="https://docs.python.org/3/reference/simple_stmts.html?highlight=global#the-global-statement">The global Statement</a></p>

<h3 id="modifying-the-global-state-from-a-nested-scope">Modifying the Global State from a Nested Scope</h3>

<p>If we would like one of our functions to have the side effect of changing or creating a global variable, we can utilize the global statement. This isn‚Äôt something that we‚Äôll use all that often since it is better to keep global state to a minimum as we start working on larger and more complex programs. But it is useful now and then. Let‚Äôs modify scopes.py so that we can change the global y variable from within our set_x function:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scopes.py

y = 5

def set_x(y):
    print("Inner y:", y)
    x = y
    global y
    y = x


set_x(10)
print("Outer y:", y)
</code></pre></div></div>

<p>If we run this, we should see the following:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>python3.7 scopes.py
  File "scopes.py", line 7
    global y
    ^
SyntaxError: name 'y' is parameter and global
</code></pre></div></div>

<p>It‚Äôs important to know that we can‚Äôt utilize the global statement if we have a parameter with the same name. Let‚Äôs change our parameter to be z before running this again:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>scopes.py

y = 5

def set_x(z):
    x = z
    global y
    global a
    y = x
    a = 7

print("y Before set_x:", y)
set_x(10)
print("y After set_x:", y)
print("a After set_x:", a)
</code></pre></div></div>

<p>We‚Äôve also created a global variable from within our set_x function called a. This variable won‚Äôt be available before the first time that set_x is called, but we should be able to print it after we‚Äôve called our function for the first time. Let‚Äôs run scopes.py again:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ python3.7 scopes.py
y Before set_x: 5
y After set_x: 10
a After set_x: 7
</code></pre></div></div>

<p>This example shows how potentially confusing using global can be. We have a function called set_x that will change the global state for the variable y. Someone who didn‚Äôt write this code could be completely confused as to why the value of the variable y that they‚Äôve been working with was changed right out from under them. Keep this in mind when considering whether or not it‚Äôs a good idea to use the global statement.</p>

<p>[]:</p>

:ET