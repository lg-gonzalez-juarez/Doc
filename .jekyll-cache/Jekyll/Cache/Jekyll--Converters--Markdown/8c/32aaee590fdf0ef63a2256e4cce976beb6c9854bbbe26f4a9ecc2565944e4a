I"ú#<h2 id="461-what-are-exceptions">46.1. What are Exceptions?</h2>

<p>Things don‚Äôt always go according to plan when we‚Äôre programming, and when issues arise, we run into exceptions. In this lesson, we‚Äôll learn about what exceptions are and when we‚Äôll run into them.</p>

<h3 id="documentation">Documentation</h3>
<ul>
  <li><a href="https://docs.python.org/3.7/tutorial/errors.html">Python Errors and Exceptions Documentation</a>
 -<a href="https://docs.python.org/3/library/exceptions.html">Python Exceptions Documentation</a></li>
</ul>

<h3 id="syntax-errors-vs-exceptions">Syntax Errors vs Exceptions</h3>

<p>As we‚Äôve been learning how to do various things with Python, we‚Äôve run into both syntax errors and exceptions. There‚Äôs a subtle difference between the two: syntax errors cannot be recovered from. The reason that we can‚Äôt recover from a syntax error is that our code is simply not valid Python code, so the parser doesn‚Äôt know what to do with anything after it runs into the error.</p>

<p>Exceptions are issues that occur during the execution of syntactically valid code that prevents the code from executing as planned. An exception occurring doesn‚Äôt necessarily mean that our program needs to fail; it might just mean that we need to do something differently.</p>

<p>An example of an exception that we can handle is a <code class="language-plaintext highlighter-rouge">TypeError</code>. This type of exception that we would run into if we tried to add an <code class="language-plaintext highlighter-rouge">int</code> and a <code class="language-plaintext highlighter-rouge">str</code> like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; 1 + 'a'
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
TypeError: unsupported operand type(s) for +: 'int' and 'str'
</code></pre></div></div>

<p>This might seem like something that we would never do, but say we had code that tried to add two different variables, without using type checking or type casting we can‚Äôt know for certain that two random variables both hold onto types that can be added, so it is possible to run into a <code class="language-plaintext highlighter-rouge">TypeError</code> in that situation.</p>

<p>As we write more and more complex code, there will be times when we need to handle errors, raise errors ourselves, and even create custom error types.</p>

<h2 id="462-handling-exceptions-with-try-except-else-and-finally">46.2. Handling Exceptions with <code class="language-plaintext highlighter-rouge">try</code>, <code class="language-plaintext highlighter-rouge">except</code>, <code class="language-plaintext highlighter-rouge">else</code>, and <code class="language-plaintext highlighter-rouge">finally</code></h2>

<p>Not everything can go according to plan in our programs, but we should know when these scenarios arise and handle them appropriately. In this lesson, we‚Äôll take a look at how to handle exceptions in Python.</p>

<h3 id="documentation-1">Documentation</h3>

<ul>
  <li><a href="https://docs.python.org/3/reference/compound_stmts.html#the-try-statement">The try statement &amp; workflow</a></li>
  <li><a href="https://docs.python.org/3/reference/compound_stmts.html#the-try-statement">Python Errors and Exceptions Documentation</a></li>
  <li><a href="https://docs.python.org/3/library/exceptions.html">Python Exceptions Documentation</a></li>
</ul>

<h3 id="handling-exceptions-with-tryexceptelsefinally">Handling Exceptions with try/except/else/finally</h3>
<p>When we know that our code can raise an exception, we don‚Äôt need to just accept it and let our program crash. We can handle these exceptions using the <a href="https://docs.python.org/3/reference/compound_stmts.html#the-try-statement">try statement</a>. This is a compound statement kind of like the if statement where we will also need to use except, and have access to else and finally. Let‚Äôs break down what these do by writing a small program that will potentially raise an exception. We‚Äôll call this program using_try.py and put it in a new directory called exception_handling:</p>

<p>$ ~/exception_handling
$ touch ~/exception_handling/using_try.py
~/exception_handling/using_try.py</p>

<p>import sys</p>

<p>print(f‚ÄùReceived argument {sys.argv[1]}‚Äù)
If we run this script with an extra argument, then it will run successfully, but if we run it without any arguments, then we‚Äôll see an exception.</p>

<p>$ python3.7 using_try.py testing
Received argument testing
$ python3.7 using_try.py
Traceback (most recent call last):
  File ‚Äúusing_try.py‚Äù, line 3, in <module>
    print(f"Received argument {sys.argv[1]}")
IndexError: list index out of range
The exception is an IndexError, and it's being raised because the list returned from sys.argv doesn't have 2 elements, so there is no index of 1. This is a completely reasonable thing for someone to do when using our script; it is easy to forget to pass in an argument. There are ways to handle this that don't involve using exception handling, but since indexing a list can potentially raise an exception, we should be ready to perform exception handling in our code.</module></p>

<p>To handle this, we need to place our code that could raise an exception within a try statement and then except, if it happens and do something else.</p>

<p>~/exception_handling/using_try.py</p>

<p>import sys</p>

<p>try:
    print(f‚ÄùReceived argument {sys.argv[1]}‚Äù)
except:
    print(f‚ÄùError: no arguments, please provide at least one argument‚Äù)
    sys.exit(1)
This is the simplest kind of try/except, and this will catch any exception that might be raised by the code inside the try block. If we run this file again, we should see our print out.</p>

<p>$ python3.7 using_try.py
Error: no arguments, please provide at least one argument
$ echo $?
1
Since this is still a case where we want to terminate our script, we‚Äôre going to explicitly exit with a non-zero status code to indicate the user that things didn‚Äôt go according to plan, but we‚Äôre also able to shield the user from seeing the Python traceback and provide a better experience to anyone using our script.</p>

<p>We could make this more specific and only except a very specific exception, and even have multiple separate except blocks catching different kinds of exceptions. Let‚Äôs introduce another potential exception and catch the exceptions separately:</p>

<p>~/exception_handling/using_try.py</p>

<p>import sys</p>

<p>try:
    print(f‚ÄùFirst argument {sys.argv[1]}‚Äù)
    args = sys.argv
    random.shuffle(args)
    print(f‚ÄùRandom argument {args[0]}‚Äù)
except IndexError as err:
    print(f‚ÄùError: no arguments, please provide at least one argument ({err})‚Äù)
    sys.exit(1)
except NameError:
    print(f‚ÄùError: random module not loaded‚Äù)
    sys.exit(1)
Let‚Äôs run this without an argument and then with an argument:</p>

<p>$ python3.7 using_try.py
Error: no arguments, please provide at least one argument (list index out of range)
$ python3.7 using_try.py testing
First argument testing
Error: random module not loaded
Notice that like a conditional statement with multiple branches, only one of the except blocks will run because as soon as an exception occurs, the execution of the try block stops. Additionally, we can assign the exception that is raised to a variable so that we can get more information from it by adding as <identifier> to our except clause.</identifier></p>

<p>The else and finally Statements
Now we‚Äôre able to handle exceptions, but the exception handling workflow also facilitates a way for us to run code if no exception gets caught using else, and there‚Äôs also a way to run some code after any error handling, or the else block, by using finally. Since we‚Äôre using sys.exit, we wouldn‚Äôt be able to use finally as is, but let‚Äôs make some modifications to see how both of these work.</p>

<p>~/exception_handling/using_try.py</p>

<p>import sys
import random</p>

<p>try:
    print(f‚ÄùFirst argument {sys.argv[1]}‚Äù)
    args = sys.argv
    random.shuffle(args)
    print(f‚ÄùRandom argument {args[0]}‚Äù)
except (IndexError, KeyError) as err:
    print(f‚ÄùError: no arguments, please provide at least one argument ({err})‚Äù)
except NameError:
    print(f‚ÄùError: random module not loaded‚Äù)
else:
    print(‚ÄúElse is running‚Äù)
finally:
    print(‚ÄúFinally is running‚Äù)
We did import random so that it is possible to successfully run the script. Let‚Äôs give this a run to see how it goes:</p>

<p>$ python3.7 using_try.py
Error: no arguments, please provide at least one argument (list index out of range)
Finally is running
$ python3.7 using_try.py testing
First argument testing
Random argument using_try.py
Else is running
Finally is running
$</p>

<h2 id="463-using-built-in-exceptions">46.3. Using Built-In Exceptions</h2>

<h2 id="464-creating-custom-exception-types">46.4. Creating Custom Exception Types</h2>

<h2 id="465-using-assertions">46.5. Using Assertions</h2>

<p>[]:</p>

:ET