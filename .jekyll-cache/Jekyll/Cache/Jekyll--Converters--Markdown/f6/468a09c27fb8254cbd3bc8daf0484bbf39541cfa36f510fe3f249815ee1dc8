I"H{<h2 id="441-what-is-an-object">44.1. What is an Object?</h2>

<p>Python is an object-oriented programming language and that means we work primarily with <code class="language-plaintext highlighter-rouge">objects</code>. In this lesson, we’ll take a closer look at what an object is.</p>

<h3 id="documentation">Documentation</h3>

<p><a href="https://docs.python.org/3/tutorial/classes.html">Python Classes Documentation</a></p>

<h3 id="what-is-an-object">What Is an Object?</h3>

<p>Objects can be a little confusing, but a good way to think about objects is that they are entities encompassing data and functionality. Let’s take a look at the built-in types we’ve been using to look at the data and functionality encompassed by them. Custom object types are more complex than the built-in types, but looking at the primitive types will help us understand objects from a high level.</p>

<p>For strings (the <code class="language-plaintext highlighter-rouge">str</code> type), the primary data that we interact with is the string itself, but that doesn’t mean it’s the only value a string encompasses. When we talk about the functionality an object encompasses, we mean the methods that the object has access to. We’ve seen a lot of methods on strings, such as <code class="language-plaintext highlighter-rouge">lower</code> and <code class="language-plaintext highlighter-rouge">upper</code>.</p>

<p>Thankfully, we can see everything an object encompasses by using the <a href="https://docs.python.org/3.3/library/functions.html#dir">dir</a> built-in function. Let’s take a look at a string in the REPL:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ python3.7
Python 3.7.6 (default, Jan 30 2020, 15:46:02)
[GCC 4.8.5 20150623 (Red Hat 4.8.5-39)] on linux
Type "help", "copyright", "credits" or "license" for more information.
&gt;&gt;&gt; my_str = "Test String"
&gt;&gt;&gt; dir(my_str)
['__add__', '__class__', '__contains__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattr
ibute__', '__getitem__', '__getnewargs__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__iter__', '__le__', '_
_len__', '__lt__', '__mod__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__rmod__', '__rm
ul__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'capitalize', 'casefold', 'center', 'count', 'encode',
'endswith', 'expandtabs', 'find', 'format', 'format_map', 'index', 'isalnum', 'isalpha', 'isascii', 'isdecimal', 'isdigit'
, 'isidentifier', 'islower', 'isnumeric', 'isprintable', 'isspace', 'istitle', 'isupper', 'join', 'ljust', 'lower', 'lstri
p', 'maketrans', 'partition', 'replace', 'rfind', 'rindex', 'rjust', 'rpartition', 'rsplit', 'rstrip', 'split', 'splitline
s', 'startswith', 'strip', 'swapcase', 'title', 'translate', 'upper', 'zfill']
</code></pre></div></div>

<p>The <a href="https://docs.python.org/3.3/library/functions.html#dir">dir function</a> returns a list of all of the variables and functions that the object encompasses. We can chain any of these items off of our object and it will return a value. That value might be a method.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; my_str.__doc__
"str(object='') -&gt; str\nstr(bytes_or_buffer[, encoding[, errors]]) -&gt; str\n\nCreate a new string object from the given object. If encoding or\nerrors is specified, then the object must expose a data buffer\nthat will be decoded using the given encoding and error handler.\nOtherwise, returns the result of object.__str__() (if defined)\nor repr(object).\nencoding defaults to sys.getdefaultencoding().\nerrors defaults to 'strict'."
&gt;&gt;&gt; my_str.isdigit
&lt;built-in method isdigit of str object at 0x7f7fc84c11f0&gt;
&gt;&gt;&gt; my_str.isdigit()
False
</code></pre></div></div>

<p>We can see the documentation for the <code class="language-plaintext highlighter-rouge">str</code> type and even access the methods from the object. A good way to tell if something is an object is to try to assign it to a variable. All objects can be assigned to variables.</p>

<h2 id="442-creating-and-using-python-classes">44.2. Creating and Using Python Classes</h2>

<p>The next step in our programming journey requires us to think about how we can model concepts from our problem. To do that, we’ll often use classes to create completely new data types. In this lesson, we’ll create our very first class and learn how to work with its data and functionality.</p>

<h3 id="python-documentation">Python Documentation</h3>

<p><a href="https://docs.python.org/3/tutorial/classes.html#classes">Classes</a></p>

<h3 id="defining-new-types">Defining New Types</h3>

<p>Up to this point, we’ve been working with the built-in types that Python provides (e.g. <code class="language-plaintext highlighter-rouge">str</code>, <code class="language-plaintext highlighter-rouge">int</code>, <code class="language-plaintext highlighter-rouge">float</code>), but when we’re modeling problems in our programs we often want more complex objects that fit our specific problem’s domain. For instance, if we were writing a program to model information about vehicles for an automotive shop, then it would make sense for us to have an object type that represents a vehicle. This is where we will start working with classes.</p>

<p>From this point on, most of the code that we’ll be writing will be in files. Let’s create a <code class="language-plaintext highlighter-rouge">python_objects</code> directory to hold these files that are only there to facilitate learning.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ mkdir ~/python_objects
$ cd ~/python_objects
</code></pre></div></div>

<h3 id="creating-our-first-class">Creating Our First Class</h3>

<p>For this lesson, we’ll use a file called <code class="language-plaintext highlighter-rouge">vehicle.py</code>. Our goal is to model a vehicle that has tires and an engine. To create a <code class="language-plaintext highlighter-rouge">class</code> we use the class keyword, followed by a name for the class, starting with a capital letter. Let’s create our first class, the <code class="language-plaintext highlighter-rouge">Vehicle</code> class:</p>

<p><code class="language-plaintext highlighter-rouge">~/python_objects/vehicle.py</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Vehicle:
    """
    Docstring describing the class
    """

    def __init__(self):
        """
        Docstring describing the method
        """
        pass
</code></pre></div></div>

<p>This is an incredibly simple class. A few things to note here are that by adding a triple-quoted string right under the definition of the class, and also right under the definition of a method or function, we can add documentation. This documentation is nice because we can add examples in this string to run as tests to help ensure our documentation stays up-to-date with the implementation.</p>

<p>A method is a function defined within the context of an object, and Python classes can define special functions that start with double underscores <code class="language-plaintext highlighter-rouge">__</code>, such as the <code class="language-plaintext highlighter-rouge">__init__</code>method. This method is the initializer for our class, and it is where we customize what happens when a new instance is being created. In practice, this method will usually just set attributes on the instance. The initializer is what is used when we create a new version of our class by running code like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; my_vehicle = Vehicle()
</code></pre></div></div>

<p>We would like our <code class="language-plaintext highlighter-rouge">Vehicle</code> class to hold a few pieces of data such as the tires and an engine. For the time being, we’re going to have those be a list containing a string for the tires and a string for the engine. Let’s modify our <code class="language-plaintext highlighter-rouge">__init__</code> method to have the <code class="language-plaintext highlighter-rouge">engine</code> and <code class="language-plaintext highlighter-rouge">tires</code> parameters:</p>

<p><code class="language-plaintext highlighter-rouge">~/python_objects/vehicle.py</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Vehicle:
    """
    Vehicle models a vehicle w/ tires and an engine
    """

    def __init__(self, engine, tires):
        self.engine = engine
        self.tires = tires
</code></pre></div></div>

<h3 id="what-is-self">What Is self?</h3>

<p>A big change from writing functions to writing methods is the presence of <code class="language-plaintext highlighter-rouge">self</code>. This variable references the individual instance of the class that we’re working with. The <code class="language-plaintext highlighter-rouge">Vehicle</code> class holds onto the information about vehicles within our program, where an instance of the <code class="language-plaintext highlighter-rouge">Vehicle</code> class could represent a specific vehicle like my Honda Civic. Let’s load our class into the REPL using <code class="language-plaintext highlighter-rouge">python3.7 -i vehicle.py</code>, and then create a specific instance of my Honda Civic.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ python3.7 -i vehicle.py
&gt;&gt;&gt; civic = Vehicle('4-cylinder', ['front-driver', 'front-passenger', 'rear-driver', 'rear-passenger'])
&gt;&gt;&gt; civic.tires
['front-driver', 'front-passenger', 'rear-driver', 'rear-passenger']
&gt;&gt;&gt; civic.engine
'4-cylinder'
</code></pre></div></div>

<p>Once we have our instance, we can access our internal attributes by using a period (.). Attributes are variables attached to the instance. Our <code class="language-plaintext highlighter-rouge">civic</code> variable has an <code class="language-plaintext highlighter-rouge">engine</code> attribute, which just means that <code class="language-plaintext highlighter-rouge">engine</code> is one of its internal variables.</p>

<h3 id="defining-a-custom-method">Defining a Custom Method</h3>

<p>The last thing that we’ll do to round out the first rendition of our class is to define a method that prints a description of the vehicle to the screen.</p>

<p><code class="language-plaintext highlighter-rouge">~/python_objects/vehicle.py</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Vehicle:
    """
    Vehicle models a vehicle w/ tires and an engine
    """

    def __init__(self, engine, tires):
        self.engine = engine
        self.tires = tires

    def description(self):
            print(f"A vehicle with an {self.engine} engine, and {self.tires} tires")
</code></pre></div></div>

<p>Our <code class="language-plaintext highlighter-rouge">description</code> method doesn’t have any actual arguments, but we pass the instance in as <code class="language-plaintext highlighter-rouge">self</code>. From there, we can access the instance’s attributes by calling <code class="language-plaintext highlighter-rouge">self.attribute_name</code>.</p>

<p>Let’s use this new method:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ python3.7 -i vehicle.py
&gt;&gt;&gt; civic = Vehicle('4-cylinder', ['front-driver', 'front-passenger', 'rear-driver', 'rear-passenger'])
&gt;&gt;&gt; civic.engine
'4-cylinder'
&gt;&gt;&gt; civic.tires
['front-driver', 'front-passenger', 'rear-driver', 'rear-passenger']
&gt;&gt;&gt; civic.description
&lt;bound method Vehicle.description of &lt;__main__.Vehicle object at 0x7fb5f3fbbda0&gt;&gt;
&gt;&gt;&gt; civic.description()
A vehicle with a 4-cylinder engine, and ['front-driver', 'front-passenger', 'rear-driver', 'rear-passenger'] tires
</code></pre></div></div>
<p>Just like a normal function, if we don’t use parenthesis, the method won’t execute.</p>

<h3 id="adding-and-removing-attributes-from-instances">Adding and Removing Attributes from Instances</h3>

<p>We’ve seen how to define attributes as part of our instance initialization code, but an instance of a custom class also acts as a namespace for any attribute we want. This means that after we create an instance of a custom class, we can add attributes to it in the same way we assign a new variable. We just need to chain the attribute off of our instance’s identifier. Let’s add a <code class="language-plaintext highlighter-rouge">serial_number</code> (attribute) to my <code class="language-plaintext highlighter-rouge">civic</code> (identifier).</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; civic.serial_number = '1234'
&gt;&gt;&gt; civic.serial_number
'1234'
</code></pre></div></div>

<p>We can remove attributes from an instance of a class using the <code class="language-plaintext highlighter-rouge">del</code> keyword, just like we would to delete a variable. Remember, we need to be accessing the attribute and not just pass in our object.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&gt;&gt;&gt; del civic.serial_number
&gt;&gt;&gt; civic.serial_number
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
AttributeError: 'Vehicle' object has no attribute 'serial_number'
</code></pre></div></div>

<h2 id="443-custom-constructors-class-methods-and-decorators">44.3. Custom Constructors, Class Methods, and Decorators</h2>

<p>There’s a lot to learn when it comes to creating and building robust classes. In this lesson, we continue to learn about some of the tools at our disposal when creating classes: custom constructors and class methods.</p>

<h3 id="documentation-1">Documentation</h3>

<ul>
  <li><a href="https://docs.python.org/3/tutorial/classes.html#classes">Classes</a></li>
  <li><a href="https://docs.python.org/3/library/functions.html#classmethod">Class Methods</a></li>
</ul>

<h3 id="custom-class-constructors">Custom Class Constructors</h3>

<p>Unlike other languages like Java, Python doesn’t provide a way for us to create multiple constructor methods. Instead, we get a single constructor method that we can customize, the <code class="language-plaintext highlighter-rouge">__init__</code> method. We’ve already customized this for our <code class="language-plaintext highlighter-rouge">Vehicle</code> class. This method has a default implementation that takes no arguments, so by defining this in our class, we’ve created a custom constructor.</p>

<h3 id="using-classmethod-to-create-convenience-constructor-methods">Using @classmethod to Create Convenience Constructor Methods</h3>

<p>Although creating multiple different constructors isn’t a feature of Python, it doesn’t mean we can’t do something similar. If we want another way to construct a <code class="language-plaintext highlighter-rouge">Vehicle</code> object with some preset values, we can create convenience methods using what is known as a class method. A class method is a function attached to the class itself, not an instance of the class, and it has access to any class-level attributes. To create a class method, we need to use what is known as a decorator. Decorators are functions or classes that we use to add additional functionality to a function by prefixing the decorator’s name with an at-sign (<code class="language-plaintext highlighter-rouge">@</code>) and putting it on the line above our function or method definition. This sounds confusing, but remember back to our look at higher-order functions. A decorator takes a function and returns another modified function in its place. For the purposes of the PCAP, we only need to know how to use one specific decorator so that we can add class methods to our classes: the <code class="language-plaintext highlighter-rouge">@classmethod</code> decorator. Let’s add a method to our <code class="language-plaintext highlighter-rouge">Vehicle</code> class that will allow us to create a bicycle (which has two wheels, and no engine).</p>

<p><code class="language-plaintext highlighter-rouge">~/python_objects/vehicle.py</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Vehicle:

    """
    Vehicle models a vehicle w/ tires and an engine
    """
    default_tire = 'tire'

    def __init__(self, engine, tires):
        self.engine = engine
        self.tires = tires

    @classmethod
    def bicycle(cls, tires=None):
        if not tires:
            tires = [cls.default_tire, cls.default_tire]
        return cls(None, tires)

    def description(self):
        print(f"A vehicle with an {self.engine} engine, and {self.tires} tires")
</code></pre></div></div>

<p>Notice we added a class-level variable called <code class="language-plaintext highlighter-rouge">default_tire</code>. This variable is set on the class itself and will also be available to instances of the class. By decorating the <code class="language-plaintext highlighter-rouge">bicycle</code> as a <code class="language-plaintext highlighter-rouge">@classmethod</code>, we’re able to call <code class="language-plaintext highlighter-rouge">Vehicle.bicycle()</code>, and the class itself will be passed in as the implicit <code class="language-plaintext highlighter-rouge">cls</code> argument (this name is a convention, not a required name). Because the class itself <code class="language-plaintext highlighter-rouge">(Vehicle)</code> is passed into the method as the <code class="language-plaintext highlighter-rouge">cls</code> variable, that means when we call <code class="language-plaintext highlighter-rouge">cls()</code>, it is equivalent to doing <code class="language-plaintext highlighter-rouge">Vehicle()</code> and will invoke the <code class="language-plaintext highlighter-rouge">__init__</code> method. It’s beneficial to use the <code class="language-plaintext highlighter-rouge">cls</code> variable instead of the class name, because if we ever change the name of the class, then we won’t need to modify this function. If no argument is passed in for the <code class="language-plaintext highlighter-rouge">tires</code> parameter, then we’ll create a default list containing the value of the <code class="language-plaintext highlighter-rouge">default_tire</code> class attribute two times. Let’s load this file into the REPL and see if it works:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ python3.7 -i vehicle.py
&gt;&gt;&gt; bike = Vehicle.bicycle()
&gt;&gt;&gt; bike
&lt;__main__.Vehicle object at 0x7f947c0f7750&gt;
&gt;&gt;&gt; bike.description()
A vehicle with an None engine, and ['tire', 'tire'] tires
&gt;&gt;&gt; bike.engine
&gt;&gt;&gt; bike.tires
['tire', 'tire']
</code></pre></div></div>

<p>As we start modeling more and more concepts, there will be more situations where we’ll want to use class methods to perform actions that require information available to only the class and doesn’t require any instance information.</p>

<h2 id="444-inheritance-and-super">44.4. Inheritance and Super</h2>

<p>Our <code class="language-plaintext highlighter-rouge">Vehicle.bicycle</code> class method does a good job of creating a vehicle that looks like a <code class="language-plaintext highlighter-rouge">bicycle</code>, but should we have a Bicycle class instead? Because a bicycle is a type of vehicle, we can leverage the code that exists in the <code class="language-plaintext highlighter-rouge">Vehicle</code> class by creating a new class that inherits from the <code class="language-plaintext highlighter-rouge">Vehicle</code> class. In this lesson, we’ll learn about inheritance, one of the core tenants of object-oriented programming (OOP).</p>

<h3 id="documentation-2">Documentation</h3>

<ul>
  <li><a href="https://docs.python.org/3/tutorial/classes.html#classes">Classes</a></li>
  <li><a href="https://docs.python.org/3.7/tutorial/classes.html#inheritance">Inheritance</a></li>
  <li><a href="https://docs.python.org/3/library/functions.html#super">Super</a></li>
</ul>

<h3 id="using-inheritance-to-customize-an-existing-class">Using Inheritance to Customize an Existing Class</h3>

<p>Our existing <code class="language-plaintext highlighter-rouge">Vehicle</code> implementation does exactly what we need it to do for a general vehicle, but there are other, more specific types of vehicles such as cars, trucks, boats, and bicycles. If we wanted to model these other types of vehicles, we could use our existing <code class="language-plaintext highlighter-rouge">Vehicle</code> class as a starting point by inheriting its existing implementation. Let’s add a new <code class="language-plaintext highlighter-rouge">Bicycle</code> class to a new file called <code class="language-plaintext highlighter-rouge">bicycle.py</code>.</p>

<p><code class="language-plaintext highlighter-rouge">~/python_objects/bicycle.py</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>from vehicle import Vehicle

class Bicycle(Vehicle):
    pass
</code></pre></div></div>

<p>By passing in the <code class="language-plaintext highlighter-rouge">Vehicle</code> class to our class definition for <code class="language-plaintext highlighter-rouge">Bicycle</code>, we’re specifying that our class is a subclass of <code class="language-plaintext highlighter-rouge">Vehicle</code>. As it stands right now, the <code class="language-plaintext highlighter-rouge">Bicycle</code> class will behave exactly like the <code class="language-plaintext highlighter-rouge">Vehicle</code> type. From here, we can add more functionality and internal states specific to a bicycle. The convenience method we added to <code class="language-plaintext highlighter-rouge">Vehicle</code> essentially allows us to have a constructor that doesn’t accept an engine, since a bicycle doesn’t have an engine. That’s what the constructor for <code class="language-plaintext highlighter-rouge">Bicycle</code> should do. Let’s customize the initializer to do this.</p>

<p><code class="language-plaintext highlighter-rouge">~/python_objects/bicycle.py</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>from vehicle import Vehicle

class Bicycle(Vehicle):
    def __init__(self, tires=[]):
        if not tires:
            tires = [self.default_tire, self.default_tire]
        self.tires = tires
</code></pre></div></div>

<p>Because <code class="language-plaintext highlighter-rouge">Bicycle</code> is a subclass of <code class="language-plaintext highlighter-rouge">Vehicle</code>, it already has access to the class-level variable <code class="language-plaintext highlighter-rouge">default_tire</code>, so we don’t need to redefine that to use it within the <code class="language-plaintext highlighter-rouge">__init__</code> method. Let’s use our class in the REPL to see if it is working correctly.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ python -i bicycle.py
&gt;&gt;&gt; bike = Bicycle()
&gt;&gt;&gt; bike.tires
['tire', 'tire']
&gt;&gt;&gt; custom_bike = Bicycle(['front-tire', 'back-tire'])
&gt;&gt;&gt; custom_bike.description()
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in &lt;module&gt;
  File "/home/cloud_user/python_objects/vehicle.py", line 18, in description
    print(f"A vehicle with an {self.engine} engine, and {self.tires} tires")
AttributeError: 'Bicycle' object has no attribute 'engine'
</code></pre></div></div>

<p>This error makes sense. Our bicycle doesn’t have an engine. We’re going to need to customize the <code class="language-plaintext highlighter-rouge">description</code> method to change the message. Looking at this error, does it make sense for <code class="language-plaintext highlighter-rouge">Vehicle</code> to require an engine and tires? Not really. A bicycle doesn’t have an engine, and a boat doesn’t have tires, so neither of those should be required. One piece of information that does describe a vehicle could be <code class="language-plaintext highlighter-rouge">distance_traveled</code>. Let’s make <code class="language-plaintext highlighter-rouge">Vehicle</code> more abstract and have the <code class="language-plaintext highlighter-rouge">description</code> only print out the distance traveled.</p>

<p><code class="language-plaintext highlighter-rouge">~/python_objects/vehicle.py</code></p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>class Vehicle:
    """
    Vehicle models a device that can be used to travel.
    """
    def __init__(self, distance_traveled=0, unit='miles'):
        self.distance_traveled = distance_traveled
        self.unit = unit

    def description(self):
        print(f"A {self.__class__.__name__} that has traveled {self.distance_traveled} {self.unit}")
</code></pre></div></div>

<p>Now our Vehicle class is much more generic and can be used as the parent class or base class for any more specific vehicle. We do need to change our Bicycle implementation now, and we will want to make sure that we’re setting a distance_traveled and unit. Thankfully, we don’t need to redo these lines, because we can use super. Let’s break down the expressions self.<strong>class</strong>.<strong>name</strong>. The variable self is an instance of Vehicle in this case, but when this method is called from a subclass, then self will be an instance of that class instead. We want to display the name of the class in our description output, so we’ll access the <strong>name</strong> attribute on the class itself. That will provide us the string value.</p>

<p>Using super()
When we want to customize a method written on a parent class without entirely replacing the method, then we’re able to invoke the parent class’s implementation of the method by calling the super() function. We need to do this to change the Bicycle.<strong>init</strong> method. A bicycle has tires, so we want that as another parameter in the initializer. Otherwise, we would like to have the initialization behave the same way as it does for Vehicle. Let’s implement <strong>init</strong>.</p>

<p>~/python_objects/bicycle.py</p>

<p>from vehicle import Vehicle</p>

<p>class Bicycle(Vehicle):
    default_tire = ‘tire’</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def __init__(self, tires=[], distance_traveled=0, unit='mile'):
    super().__init__(distance_traveled, unit)
    if not tires:
        tires = [self.default_tire, self.default_tire]
    self.tires = tires By calling super(), we have access to the methods implemented in our parent class, Vehicle. We'll then call the __init__ method with the proper parameters. The self, in the context of this call to __init__, is our Bicycle instance. So, this method call will set distance_traveled (self.distance_traveled=0) and unit (self.unit = 'miles') on our Bicycle class. We're leveraging code from the parent class while adding a little more to the initialization of this new class.
</code></pre></div></div>

<p>Let’s take this into the REPL to see how it works.</p>

<p>$ python3.7
Python 3.7.6 (default, Jan 30 2020, 15:46:02)
[GCC 4.8.5 20150623 (Red Hat 4.8.5-39)] on linux
Type “help”, “copyright”, “credits” or “license” for more information.</p>
<blockquote>
  <blockquote>
    <blockquote>
      <p>from vehicle import Vehicle
from bicycle import Bicycle
vehicle = Vehicle()
bike = Bicycle()
vehicle.description()
A Vehicle that has traveled 0 miles
bike.description()
A Bicycle that has traveled 0 mile
As we can see, description outputs something different for the Bicycle without us even changing it because we wrote it in a generic, context-aware way. That being said, we would like to add information about our tires to the description too, and once again this is a situation where we can leverage super. To make this a little quicker to test, we’ll also add a <strong>name</strong> == “<strong>main</strong>” condition with some code to demonstrate what we’re writing.</p>
    </blockquote>
  </blockquote>
</blockquote>

<p>~/python_objects/bicycle.py</p>

<p>from vehicle import Vehicle</p>

<p>class Bicycle(Vehicle):
    default_tire = ‘tire’</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def __init__(self, tires=[], distance_traveled=0, unit='mile'):
    super().__init__(distance_traveled, unit)
    if not tires:
        tires = [self.default_tire, self.default_tire]
    self.tires = tires

def description(self):
    initial = super().description()
    return f"{initial} on {len(self.tires)} tires."
</code></pre></div></div>

<p>if <strong>name</strong> == “<strong>main</strong>”:
    bike = Bicycle()
    print(bike.description())
It doesn’t really make sense for the call to description to print the information. That just makes it hard to work with. What we’ve written here works a little better and allows us to control when we’re using the class that is going to be printed. We want the initial string provided by Vehicle, and then we’ll customize it to show a little information about how many tires we have. Because of how Vehicle.description is currently written, this won’t quite work the way we would like because its printing the description on two lines.</p>

<p>$ python3.7 bicycle.py
A Bicycle that has traveled 0 mile
None on 2 tires.
Let’s fix this by making Vehicle.description return a string, rather than the side-effect of printing a message.</p>

<p>~/python_objects/vehicle.py</p>

<p>class Vehicle:
    “””
    Vehicle models a device that can be used to travel.
    “””
    def <strong>init</strong>(self, distance_traveled=0, unit=’miles’):
        self.distance_traveled = distance_traveled
        self.unit = unit</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>def description(self):
    return f"A {self.__class__.__name__} that has traveled {self.distance_traveled} {self.unit}" Let's run bicycle.py one last time to see that the description is now on one line.
</code></pre></div></div>

<p>$ python3.7 bicycle.py
A Bicycle that has traveled 0 miles on 2 tires.
We’ve learned quite a bit in this lesson about inheritance and super, but also how not to design our objects. Sometimes our initial thoughts about our objects are just not right and can make working with the items harder than we originally imagined.</p>

<h2 id="445-single-and-multiple-inheritance">44.5. Single and Multiple Inheritance</h2>

<h2 id="446-name-mangling">44.6. Name Mangling</h2>

<h2 id="447-inspecting-objects">44.7. Inspecting Objects</h2>

<p>[]:</p>

:ET